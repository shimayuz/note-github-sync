# 複数Markdownファイル管理のためのID管理方式設計

## 1. 課題の整理

### 1.1 現在の設計の課題

当初の設計では、各Markdownファイルの**Frontmatter内に`note_id`を直接記述**する方式を提案しました。しかし、この方式には以下の課題があります。

| 課題 | 説明 |
| :--- | :--- |
| **ファイル更新の競合** | n8nがGitHub APIで`note_id`を書き戻す際、ユーザーがObsidianで同時に編集していると競合が発生する |
| **Git履歴の汚染** | BOTによる自動コミットが頻繁に発生し、Git履歴が読みにくくなる |
| **スケーラビリティの欠如** | 複数ファイルを一度にプッシュした場合、各ファイルへの書き戻しが順次実行され、処理時間が長くなる |
| **管理の複雑化** | ディレクトリ構造が深い場合、どのファイルがどのnote IDに対応しているかを把握しにくい |

### 1.2 改善の方向性

これらの課題を解決するため、以下の方針で設計を改善します。

1. **外部データベースでのID管理**: Frontmatterではなく、外部のマッピングファイルまたはデータベースでファイルパスとnote IDの対応関係を管理します。
2. **リポジトリ内のマッピングファイル**: GitHubリポジトリ内に`.note-mapping.json`のようなマッピングファイルを配置し、ファイルパスとnote IDの対応を記録します。
3. **n8nでの一元管理**: n8nワークフロー内でマッピングファイルを読み込み・更新し、各Markdownファイルへの書き戻しを不要にします。

---

## 2. ID管理方式の設計

### 2.1 マッピングファイルの構造

リポジトリのルートディレクトリに`.note-mapping.json`というファイルを配置し、以下の構造でファイルパスとnote IDを管理します。

```json
{
  "version": "1.0",
  "last_updated": "2025-11-07T12:34:56Z",
  "mappings": {
    "articles/tech/ai-automation.md": {
      "note_id": "n4f0c7b884789",
      "title": "AI自動化の未来",
      "created_at": "2025-11-01T10:00:00Z",
      "updated_at": "2025-11-07T12:34:56Z"
    },
    "articles/lifestyle/morning-routine.md": {
      "note_id": "n5g1d8c995890",
      "title": "朝のルーティン",
      "created_at": "2025-11-02T08:30:00Z",
      "updated_at": "2025-11-05T15:20:00Z"
    },
    "drafts/new-article.md": {
      "note_id": null,
      "title": "新しい記事（未投稿）",
      "created_at": "2025-11-07T09:00:00Z",
      "updated_at": null
    }
  }
}
```

### 2.2 フィールド説明

| フィールド | 説明 |
| :--- | :--- |
| `version` | マッピングファイルのバージョン |
| `last_updated` | マッピングファイルの最終更新日時 |
| `mappings` | ファイルパスをキーとしたマッピングオブジェクト |
| `mappings[path].note_id` | note.comの記事ID（未投稿の場合は`null`） |
| `mappings[path].title` | 記事のタイトル（参照用） |
| `mappings[path].created_at` | 初回投稿日時 |
| `mappings[path].updated_at` | 最終更新日時 |

### 2.3 マッピングファイルの利点

| 利点 | 説明 |
| :--- | :--- |
| **競合の回避** | Markdownファイル自体を更新しないため、ユーザーの編集と競合しない |
| **Git履歴の整理** | マッピングファイルのみが更新されるため、Git履歴がシンプルになる |
| **一括処理** | 複数ファイルの投稿後、マッピングファイルを1回だけ更新すれば良い |
| **可視性の向上** | すべてのファイルとnote IDの対応関係を1つのファイルで確認できる |

---

## 3. Frontmatterの簡素化

マッピングファイルを導入することで、Frontmatterから`note_id`フィールドを削除できます。Frontmatterには、タイトルとタグのみを記述します。

### 3.1 新しいFrontmatterテンプレート

```yaml
---
title: "記事タイトル"
tags: ["タグ1", "タグ2", "タグ3"]
---

## はじめに

記事の本文をここに記述します。
```

### 3.2 Frontmatterのフィールド

| フィールド | 必須 | 説明 |
| :--- | :--- | :--- |
| `title` | ✅ | 記事のタイトル |
| `tags` | ❌ | タグのリスト（最大10個） |

---

## 4. ワークフローへの影響

### 4.1 変更点

n8nワークフローに以下の変更を加えます。

1. **マッピングファイルの読み込み**: ワークフロー開始時に`.note-mapping.json`をGitHubから取得します。
2. **note IDの検索**: 処理対象のMarkdownファイルのパスをキーに、マッピングファイルから`note_id`を検索します。
3. **マッピングファイルの更新**: 投稿成功後、マッピングファイルに新しいnote IDを追加または更新します。
4. **マッピングファイルのコミット**: 更新されたマッピングファイルをGitHubにコミットします。

### 4.2 処理フロー

```
1. Webhookトリガー
2. マッピングファイル読み込み
3. 変更されたファイルのリストを取得
4. 各ファイルに対して:
   a. ファイル内容を取得
   b. Frontmatterをパース
   c. マッピングファイルからnote IDを検索
   d. note-MCP-serverに投稿
   e. マッピングファイルを更新（メモリ内）
5. マッピングファイルをGitHubにコミット
```

---

## 5. 代替案: n8nデータベースでの管理

マッピングファイルをGitHubに配置する代わりに、n8nの内部データベース（PostgreSQL、MySQL等）で管理する方法もあります。

### 5.1 データベーステーブル構造

```sql
CREATE TABLE note_mappings (
  id SERIAL PRIMARY KEY,
  file_path VARCHAR(500) UNIQUE NOT NULL,
  note_id VARCHAR(100),
  title VARCHAR(500),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP
);
```

### 5.2 メリット

- GitHubへのコミットが不要になり、処理が高速化します。
- SQLクエリで柔軟な検索が可能になります。
- 大量のファイルを管理する場合に有利です。

### 5.3 デメリット

- n8nとは別にデータベースのセットアップが必要です。
- GitHubリポジトリ単体では対応関係が分からなくなります。

---

## 6. 推奨方式

**推奨**: `.note-mapping.json`ファイルをGitHubリポジトリに配置する方式

### 理由

- セットアップが簡単で、追加のインフラが不要です。
- GitHubリポジトリ内で完結するため、ポータビリティが高いです。
- 小〜中規模のファイル数（数百〜数千ファイル）であれば、パフォーマンス上の問題はありません。
- バージョン管理により、マッピングファイルの変更履歴も追跡できます。

大規模なシステム（数万ファイル以上）や、複数のワークフローで共有する場合は、データベース方式を検討してください。

---

## 7. まとめ

本設計により、以下の改善が実現します。

- **Markdownファイルへの書き戻しが不要**になり、競合リスクが解消されます。
- **Git履歴がクリーン**になり、ユーザーの変更とBOTの変更が分離されます。
- **複数ファイルの一括処理**が効率化され、処理時間が短縮されます。
- **ファイルとnote IDの対応関係**が一元管理され、可視性が向上します。

次のフェーズでは、この設計に基づいたn8nワークフローの詳細を提示します。
