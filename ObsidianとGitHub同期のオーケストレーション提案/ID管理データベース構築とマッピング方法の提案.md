# ID管理データベース構築とマッピング方法の提案

## 1. はじめに

Obsidian Vault内の複数ディレクトリに存在する各Markdownファイルに、それぞれ固有のnote.com記事ID（`note_id`）を紐付け、安定かつ効率的に管理するための方式を提案します。

当初の「Frontmatterへの直接書き込み」方式は、ファイル競合やGit履歴の汚染といった課題を抱えています。本提案では、これらの課題を解決する**外部IDマッピング方式**を提示します。

## 2. 推奨方式: マッピングファイルによる管理

**最も推奨する方式は、GitHubリポジトリ内に`.note-mapping.json`というJSONファイルを配置し、ファイルパスと`note_id`の対応関係を一元管理する方法です。**

### 2.1 `.note-mapping.json`の仕様

- **配置場所**: GitHubリポジトリのルートディレクトリ
- **役割**: リポジトリ内の全Markdownファイルの投稿状況（`note_id`、タイトル、更新日時など）を記録する唯一の信頼できる情報源（Single Source of Truth）として機能します。

#### ファイル構造

```json
{
  "version": "1.0",
  "last_updated": "2025-11-07T12:34:56Z",
  "mappings": {
    "articles/tech/ai-automation.md": {
      "note_id": "n4f0c7b884789",
      "title": "AI自動化の未来",
      "created_at": "2025-11-01T10:00:00Z",
      "updated_at": "2025-11-07T12:34:56Z"
    },
    "articles/lifestyle/morning-routine.md": {
      "note_id": "n5g1d8c995890",
      "title": "朝のルーティン",
      "created_at": "2025-11-02T08:30:00Z",
      "updated_at": "2025-11-05T15:20:00Z"
    }
  }
}
```

#### フィールド詳細

| キー | 説明 |
| :--- | :--- |
| `mappings` | ファイルパスをキーとするマッピングオブジェクト。これが管理の核となります。 |
| `mappings[path].note_id` | 対応するnote.comの記事ID。未投稿の場合は`null`。 |
| `mappings[path].title` | 記事のタイトル。管理画面やログでの可読性向上のために記録します。 |
| `mappings[path].created_at` | 初回投稿日時。 |
| `mappings[path].updated_at` | 最終更新日時。 |

### 2.2 n8nワークフローでの実装方法

1.  **読み込み**: ワークフロー開始時に、GitHubから`.note-mapping.json`を読み込みます。
2.  **検索**: 処理対象のMarkdownファイルのパスをキーとして、メモリ上のマッピングオブジェクトから`note_id`を検索します。
3.  **更新**: note.comへの投稿後、返却された`note_id`を使ってメモリ上のマッピングオブジェクトを更新します。
4.  **書き込み**: ワークフローの最後に、変更があった場合のみ、更新されたマッピングオブジェクトを`.note-mapping.json`としてGitHubにコミットします。

### 2.3 この方式の利点

- **インフラ不要**: 追加のデータベースやサーバーが不要で、GitHubリポジトリ内で完結します。
- **ポータビリティ**: リポジトリをクローンするだけで、すべての対応関係が手に入ります。
- **バージョン管理**: `note_id`の変更履歴もGitで管理できます。
- **競合回避**: Markdownファイル自体を更新しないため、ユーザーの編集作業と競合しません。

---

## 3. 代替方式: 外部データベースによる管理

より大規模なシステム（数万ファイル以上）や、高度な検索要件がある場合には、n8nが接続可能な外部データベース（PostgreSQL, MySQL, SQLiteなど）でIDを管理する方法も考えられます。

### 3.1 テーブル構造の例

```sql
CREATE TABLE note_mappings (
  id SERIAL PRIMARY KEY, -- 主キー
  file_path VARCHAR(500) UNIQUE NOT NULL, -- ファイルパス（一意制約）
  note_id VARCHAR(100), -- note.comの記事ID
  title VARCHAR(500), -- 記事タイトル
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, -- 作成日時
  updated_at TIMESTAMP WITH TIME ZONE -- 更新日時
);
```

### 3.2 n8nワークフローでの実装方法

- **読み込み**: `PostgreSQL`ノードなどを使用し、`SELECT note_id FROM note_mappings WHERE file_path = '...'`クエリで`note_id`を取得します。
- **書き込み**: `INSERT ... ON CONFLICT ... DO UPDATE`（UPSERT）クエリを使用して、投稿後に`note_id`をデータベースに書き込みます。

### 3.3 メリットとデメリット

| メリット | デメリット |
| :--- | :--- |
| **スケーラビリティ**: 大量のデータを高速に処理可能 | **インフラコスト**: データベースのセットアップと管理が必要 |
| **柔軟な検索**: SQLによる複雑なクエリが可能 | **複雑性の増加**: ワークフローの設定が複雑になる |
| **トランザクション**: 複数の更新を安全に実行可能 | **ポータビリティの低下**: GitHubリポジトリとDBが分離される |

---

## 4. 結論と推奨

| 観点 | マッピングファイル方式 | データベース方式 |
| :--- | :--- | :--- |
| **セットアップの容易さ** | **◎** | △ |
| **管理コスト** | **◎** | △ |
| **ポータビリティ** | **◎** | ✕ |
| **スケーラビリティ** | ○ | ◎ |
| **推奨度** | **★★★★★** | ★★★☆☆ |

**結論として、`.note-mapping.json`ファイルをリポジトリに配置する方式を強く推奨します。**

この方式は、Obsidian Vaultの規模であれば十分なパフォーマンスを発揮し、何よりもセットアップと管理が非常にシンプルです。将来的にシステムが極端に大規模化した場合に、データベース方式への移行を検討すれば十分です。

次のステップでは、この推奨方式に基づいた最終的な実装ガイドを提示します。
